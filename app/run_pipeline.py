# app/run_pipeline.py
import os
import json
from datetime import datetime
from typing import Tuple, Dict, Any, Optional

from agents.planner_agent import PlannerAgent
from agents.security_guide_agent import SecurityGuideAgent
from agents.coder_agent import CoderAgent
from agents.simulation_agent import SimulationAgent
from oracles.param_oracle import ParamOracle
from oracles.safety_oracle import SafetyOracle
from oracles.mode_oracle import ModeOracle


def llm_as_judge(code: str) -> Tuple[bool, str]:
    """
    Perform a first-level safety check on the generated code.
    :param code: Code to verify
    :return: (safety pass/fail, feedback)
    """
    print("[LLM as Judge] Starting safety verification...")
    # Example: consider unsafe if no try-except block
    if "try:" not in code or "except" not in code:
        feedback = (
            "The code is missing exception handling (try-except). "
            "Please add it to handle potential runtime errors."
        )
        print(f"[LLM as Judge] Verification failed: {feedback}")
        return False, feedback
    print("[LLM as Judge] Verification passed.")
    return True, "LLM as Judge verification passed."


class PipelineRunner:
    def __init__(self, initial_instruction: str, max_retries: int = 3):
        self.instruction: str = initial_instruction
        self.max_retries: int = max_retries
        self.retries: int = 0

        # Initialize Agents and Oracles
        self.planner = PlannerAgent()
        self.security_guide = SecurityGuideAgent()
        self.coder = CoderAgent()
        self.simulator = SimulationAgent()
        self.oracles = [ParamOracle(), SafetyOracle(), ModeOracle()]

        # Variables to store results
        self.plan: Optional[str] = None
        self.security_guidelines: Optional[str] = None
        self.generated_code: Optional[str] = None
        self.simulation_result: Optional[Dict[str, Any]] = None
        self.final_feedback: Dict[str, Any] = {}

    def run(self):
        """Run the entire pipeline."""
        print("Starting ROS Secure Code Generation and Verification Pipeline")

        # 1. Planner creates the plan
        self.plan = self.planner.generate_plan(self.instruction)
        print("\nPlan generated by Planner:\n", self.plan)

        while self.retries < self.max_retries:
            print(f"\n--- Attempt: {self.retries + 1}/{self.max_retries} ---")

            # Phase 1: Generation
            if not self._run_generation_phase():
                self.retries += 1
                continue

            # Phase 2: Evaluation
            passed, feedback = self._run_evaluation_phase()
            if passed:
                print("\nAll checks passed. Pipeline completed successfully.")
                self.final_feedback["status"] = "Success"
                self.save_results()
                return self.generated_code, self.final_feedback

            # Process feedback and retry
            self._process_feedback(feedback)
            self.retries += 1

        print(f"\nMaximum retries exceeded ({self.max_retries}). Pipeline failed.")
        self.final_feedback["status"] = "Failed"
        self.save_results()
        return None, self.final_feedback

    def _run_generation_phase(self) -> bool:
        """Execute the secure code generation phase."""
        print("\n--- Phase 1: Generation ---")

        # 2. Security Guide generates guidelines
        self.security_guidelines = self.security_guide.generate_guidelines(self.plan)
        print("\nGuidelines generated by Security Guide:\n", self.security_guidelines)

        # 3. Coder generates code
        self.generated_code = self.coder.generate_code(self.plan, self.security_guidelines)
        print("\nCode generated by Coder:\n", self.generated_code)

        # 4. LLM as Judge first check
        is_safe, judge_feedback = llm_as_judge(self.generated_code)
        if not is_safe:
            print("\n[Feedback Loop] LLM as Judge failed. Passing feedback to Coder.")
            self.plan += (
                f"\n[Revision Request] Please incorporate this feedback from the "
                f"previous code attempt: {judge_feedback}"
            )
            return False

        return True

    def _run_evaluation_phase(self) -> Tuple[bool, Dict[str, Dict[str, Any]]]:
        """Execute the Oracle verification phase."""
        print("\n--- Phase 2: Evaluation ---")

        # 5. Simulation Agent runs simulation
        self.simulation_result = self.simulator.run_simulation(self.generated_code)
        print("\nSimulation Result:\n", self.simulation_result)

        # 6. Oracles verify in parallel
        all_passed = True
        feedback_summary: Dict[str, Dict[str, Any]] = {}
        for oracle in self.oracles:
            passed, feedback = oracle.verify(self.generated_code, self.simulation_result)
            feedback_summary[oracle.name] = {"passed": passed, "feedback": feedback}
            if not passed:
                all_passed = False

        return all_passed, feedback_summary

    def _process_feedback(self, feedback: Dict[str, Dict[str, Any]]):
        """Handle feedback when Oracle verification fails."""
        print("\n[Feedback Loop] Oracle verification failed. Processing feedback...")

        if "ParamOracle" in feedback and not feedback["ParamOracle"]["passed"]:
            print("-> ParamOracle failed: passing feedback to Coder")
            self.plan += f"\n[Revision Request] Parameter feedback: {feedback['ParamOracle']['feedback']}"

        if "SafetyOracle" in feedback and not feedback["SafetyOracle"]["passed"]:
            print("-> SafetyOracle failed: passing feedback to Security Guide")
            self.plan += f"\n[Revision Request] Security guideline feedback: {feedback['SafetyOracle']['feedback']}"

        if "ModeOracle" in feedback and not feedback["ModeOracle"]["passed"]:
            print("-> ModeOracle failed: passing feedback to Planner")
            self.instruction += (
                f"\n[Plan Revision Request] Mode sequence issue detected. "
                f"Please incorporate this feedback: {feedback['ModeOracle']['feedback']}"
            )
            self.plan = self.planner.generate_plan(self.instruction)
            print("\nRevised plan by Planner:\n", self.plan)

    def save_results(self):
        """Save pipeline results to files."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = "data/pipeline_results"
        os.makedirs(output_dir, exist_ok=True)

        result = {
            "instruction": self.instruction,
            "plan": self.plan,
            "security_guidelines": self.security_guidelines,
            "generated_code": self.generated_code,
            "simulation_result": self.simulation_result,
            "final_feedback": self.final_feedback,
            "retries": self.retries,
        }

        result_path = os.path.join(output_dir, f"pipeline_result_{timestamp}.json")
        with open(result_path, "w", encoding="utf-8") as f:
            json.dump(result, f, ensure_ascii=False, indent=4)

        if self.generated_code is not None:
            code_path = os.path.join(output_dir, f"generated_code_{timestamp}.py")
            with open(code_path, "w", encoding="utf-8") as f:
                f.write(self.generated_code)
            print(f"\nResults saved to {result_path} and {code_path}")
        else:
            print(f"\nResults saved to {result_path}. No code file written (generated_code is None).")


if __name__ == "__main__":
    # User request
    initial_instruction = (
        "Write a simple ROS2 publisher node that stops when an obstacle is detected. "
        "Receive sensor data from '/scan' topic with LaserScan type, and send movement "
        "commands using '/cmd_vel' topic with Twist type."
    )

    # Run pipeline
    pipeline = PipelineRunner(initial_instruction)
    final_code, report = pipeline.run()

    if final_code:
        print("\nFinal generated secure code:\n")
        print(final_code)
    else:
        print("\nFailed to generate final code. Please check the report:\n")
        print(json.dumps(report, indent=4))